# 인덱스 
- 원하는 데이터를 쉽게 찾을 수 있도록 돕는 책의 찾아보기와 유사한 개념
- ! 무조건 인덱스를 만든다고 좋은 것은 아님 ( 자원이기 때문에 너무 많으면 데이터베이스 부하 )
- 인덱스는 인덱스 키로 정렬되어 있기 때문에 원하는 데이터를 빠르게 조회
- 테이블을 생성할 때 기본키는 자동으로 인덱스가 만들어지고 인덱스 이름은 SYSXXXX이다
- 인덱스 구조는 ROOT BLOCK, BRANCH BLOCK, LEAF BLOCK 으로 구성되며 ROOT BLOCK이 가장 상위
- BRANCH BLOCK 은 다음단계의 주소를 가지고 있는 포인터로 이루어져 있음
- LEAF BLOCK은 인덱스 키와 ROWID 로 구성되고 인덱스 키는 정렬되어서 저장 (양방향 탐색이 가능)
- LEAF BLOCK 에서 인덱스 키를 읽으면 ROWID를 사용해서 EMP 테이블의 행을 직접 읽을 수 있음

| 구조요약 |
|-----|
| ROOT BLOCK(가장 상위) - BRANCH BLOCK (LEAF 주소를 보관하는 포인터) - LEAF BLOCK ( 인덱스와 ROW ID로 구성 )|

## B-TREE 인텍스에서 원하는 값 찾는 과정
1. 브랜치 블록의 가장 왼쪽 값이 찾고자 하는 값보다 작거나 같으면 왼쪽 포인터로 이동
2. 찾고자 하는 값이 브랜치 블록의 값 사이에 존재하면 가운데 포인터로 이동
3. 오른쪽에 있는 값보다 크면 오른쪽 포인터로 이동

## 인덱스 생성
- **CREATE INDEX** 문을 사용해서 생성이 가능
- 인덱스를 생성할 때는 한 개 이상의 칼럼을 사용해서 생성
- 인덱스 키는 기본적으로 오름차순으로 정렬 / DESC 사용하면 내림차순으로 정렬 <br/>
-EX ) CREATE INDEX IND_EMP ON EMP (ENAME ASC, SAL DESC);

## 인텍스 스캔
- 인덱스를 구성하는 칼럼의 값을 기반으로 데이터를 추출하는 엑세스 기법

**1. 인텍스 유일 스캔**
   -  인덱스의 키 값이 중복되지 않는 경우 해당 인덱스를 사용할 때 발생한다!
   -  유일한 익덱스 키를 검색하므로 속도가 가장 빠름
   ```
    // EMPNO가 중복되지 않는 경우 특정 하나의 EMPNO를 조회
    SELECT * FROM EMP WHERE EMPNO=10000;
   ```
    
**2. 인덱스 범위 스캔**
   - SELECT 문에서 특정 범위를 조회하는 WHERE 문을 사용할 경우 발생
   - LIEK, BETWEEN 등이 대표적 예시 / 데이터 양이 적은 경우 인덱스 자체 실행하지 않고 TABLE FULL SCAN이 될 수 있음
   - LEAF BLOCK의 특정 범위를 스캔하는 것 
 
**3. 인덱스 역순 범위 스캔** 
   - 인덱스의 리프 블록의 양방향 링크를 이용하여 내림차순으로 데이터를 읽음
   
**4. 인덱스 전체 스캔 (INDEX FULL SCAN)**
   - 인덱스에서 검색되는 인덱스 키가 많은 경우 LEAF BLOCK의 처음부터 끝까지 읽어 들임
   ```
   SELECT ENAME, SAL 
   FROM EMP 
   WHERE EMP LIKE '%' AND SAL > 0;
   ```
   ```
   select * from emp, DEPT
   where emp.DEPTNO = DEPT.DEPTNO
   and emp.DEPTNO = 10;
   ```
**5. 테이블 전체 스캔**
   - 테이블의 데이터를 모두 읽는 것을 의미
      - 전체 테이블을 스캔하는 경우 <br/> 
      1.SQL 문에 조건이 존재하지 않는 경우 <br/>
      2.SQL 문의 주어진 조건에 사용 가능한 인덱스가 존재하지 않는 경우<br/>
      3.옵티마이저의 취사 선택<br/>
      4.병렬 처리 방식으로 처리하는 경우 등<br/>

