# 1,2,11>
## 데이터 모델링
- 3가지 관점 : 데이터(데이터) / 프로세스(업무) / 데이터와 프로세스(영향)    
- 3가지 요소 : 속성(attribute), 엔터티(things), 관계(relationship)  
- 단계 : 개념(EA수립,추상화), 논리(완료된 상태, 정규화), 물리적 데이터 모델링

# 3>  
## 엔터티 구분
- **발생 시점**(중기행): **기본, 중심, 행위 엔터티**    
- **유무형**   (유개사): **유형, 개념, 사건 엔터티**   

# 4>
## 속성 구분
- **특성**에 따른 분류 : **기본, 설계, 파생**
- **엔터티 구성 방식** : **기본키, 외래키, 일반** 속성

# 5>
엔터티의 특징 :  
1. 2개 이상의 인스턴스(=인스턴스의집합)
2. 속성을 가짐 (=> 한 속성의 속성값은 하나여야 함.)  
3. 업무 프로세스에 이용
4. 관계를 가짐

# 9>
## 식별자 구분
- 대체 유무 : 본질식별자, 인조식별자
- 스스로 생성 : 내부식별자, 외부식별자
- 대표성 : 주식별자, 보조식별자

# 14>  
## 분산 데이터 베이스의 특징  
- 투명성 (ㅂx2 ㅈx3 ox1) : **분할, 병행, 장애, 중복, 지역(각 지역 시스템이름과 무관한이름 사용가능), 위치** 투명성

# 15> 
## Hash Join
**equal join만 가능**, 인덱스 사용하지 않기에 없어도 됨, 해시 테이블을 메모리에 생성(안되면 디스크), **결과 행의 수가 적은 테이블을 선행테이블로!**
## Nested Loop Join 
인덱스 필요함, 먼저 선행 테이블에 접근, 무작위로 조회됨
## Sort Merge Join
인덱스 사용하지 않기에 없어도 됨, sort됨

# 18>
## 정규화
1차 정규화 : 속성은 중복된 값을 가지지 않는다  
2차 정규화 : 식별자 전체 속성에 대해 종속해야 한다  
3차 정규화 : 식별자를 제외한 일반 속성 간에 종속을 제거한다.

# 24
테이블의 반정규화 기법 중, 데이터 무결성을 깨뜨리지 않고서도 데이터 처리의 성능을 향상시킬수 있는 기법은? - 중복관계 추가

# 35
commit과 rollback의 장점 : 데이터 무결성 보장, 영구적인 변경 전에 데이터 변경사항 확인가능

# 46

# 50>
절차형 : procedure, trigger, user-defined

# 51> 
## 옵티마이저  
- 규칙기반 : 인덱스를 이용한 엑세스 방식가 최우선,조인테이블의 우선순위가 같다면 from 절에 나열된 테이블의 역순으로 선행 테이블을 선택!    
- 비용기반 : sql문을 처리하는 데 필요한 비용이 가장 적은 실행계획을 선택, 통계    

# 69,102>
## case 
* [ case when is null then -1 else 0 ] vs [ case when null then -1 else 0 ] : null인 값을 찾고 싶다면, 왼쪽이 맞는 것이다!   
만약, else를 생략했는데, else에 해당되는 값이 나오면 Null로 지정된다.

> Select distinct a,b from ~ : 이렇게 쓰면, distinct(a,b)와 같은 의미이다!    

# 71>
## SQL sort하면 oracle은 맨뒤에, SQL server는 맨 앞에 정렬된다
(외울 때 나는 SQL server는 더 조심성있어서 맨앞에 가져와 널값을 확인할 수 있도록 한다고 외움.)


# 81>
## 인덱스는 변형을 하면 안된다, null 검사도 안됨  


# 86 >
## Index Organized Table : 테이블을 탐색하지 않고 fetch

# 98


# 106>
ROWNUM=1 가능,  
ROWNUM=N 불가능,  
ROWNUM<=N 가능!  

# 114>
null이 아닌 값을 찾고 싶으면 **'IS NOT NULL'**

# 123>
인덱스 만들기  
Create index 인덱스명 on emp(sal desc);  

# 127>
**join조건이 없다면, 카테시안 곱이 된다!!!**

# 129>
**NTILE(3)** : 1,2,3 3개로 등분, 만약 총 행의 수가 10이었다면 3+1, 3, 3 이렇게 등분된다.


# 137>
서브 쿼리 ; 한 종류인 인라인 뷰에서만 메인 쿼리에서 사용이 가능하다

# 142>
```sql
select decode(empno, 1, 'A', 'B') from emp;

select case empno when 1 then 'A' else 'B' end;
```

# 144>
## CUME_DIST() : 주어진 그룹에 대한 상대적인 누적분포도 값을 반환

># 계층형 쿼리
1. 135번(p.295)
2. 147번(p.300)

># sql 수행 계획 
1. 148번(p.300)
2. 150번(p.301)
